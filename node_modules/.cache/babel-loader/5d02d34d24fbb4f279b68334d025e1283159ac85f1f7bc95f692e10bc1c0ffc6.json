{"ast":null,"code":"let Promise = global.Promise;\n\n/// encapsulate a method with a node-style callback in a Promise\n/// @param {object} 'this' of the encapsulated function\n/// @param {function} function to be encapsulated\n/// @param {Array-like} args to be passed to the called function\n/// @return {Promise} a Promise encapsulating the function\nfunction promise(fn, context, args) {\n  if (!Array.isArray(args)) {\n    args = Array.prototype.slice.call(args);\n  }\n  if (typeof fn !== 'function') {\n    return Promise.reject(new Error('fn must be a function'));\n  }\n  return new Promise((resolve, reject) => {\n    args.push((err, data) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n    fn.apply(context, args);\n  });\n}\n\n/// @param {err} the error to be thrown\nfunction reject(err) {\n  return Promise.reject(err);\n}\n\n/// changes the promise implementation that bcrypt uses\n/// @param {Promise} the implementation to use\nfunction use(promise) {\n  Promise = promise;\n}\nmodule.exports = {\n  promise,\n  reject,\n  use\n};","map":{"version":3,"names":["Promise","global","promise","fn","context","args","Array","isArray","prototype","slice","call","reject","Error","resolve","push","err","data","apply","use","module","exports"],"sources":["C:/Users/user1/Documents/יעלי/סמינר/תכנות/שנה ב/practicode/practicod3-kravitz-yaeli/TodoApi/node_modules/bcrypt/promises.js"],"sourcesContent":["let Promise = global.Promise;\n\n/// encapsulate a method with a node-style callback in a Promise\n/// @param {object} 'this' of the encapsulated function\n/// @param {function} function to be encapsulated\n/// @param {Array-like} args to be passed to the called function\n/// @return {Promise} a Promise encapsulating the function\nfunction promise(fn, context, args) {\n    if (!Array.isArray(args)) {\n        args = Array.prototype.slice.call(args);\n    }\n\n    if (typeof fn !== 'function') {\n        return Promise.reject(new Error('fn must be a function'));\n    }\n\n    return new Promise((resolve, reject) => {\n        args.push((err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n\n        fn.apply(context, args);\n    });\n}\n\n/// @param {err} the error to be thrown\nfunction reject(err) {\n    return Promise.reject(err);\n}\n\n/// changes the promise implementation that bcrypt uses\n/// @param {Promise} the implementation to use\nfunction use(promise) {\n    Promise = promise;\n}\n\nmodule.exports = {\n    promise,\n    reject,\n    use\n}\n"],"mappings":"AAAA,IAAIA,OAAO,GAAGC,MAAM,CAACD,OAAO;;AAE5B;AACA;AACA;AACA;AACA;AACA,SAASE,OAAOA,CAACC,EAAE,EAAEC,OAAO,EAAEC,IAAI,EAAE;EAChC,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;IACtBA,IAAI,GAAGC,KAAK,CAACE,SAAS,CAACC,KAAK,CAACC,IAAI,CAACL,IAAI,CAAC;EAC3C;EAEA,IAAI,OAAOF,EAAE,KAAK,UAAU,EAAE;IAC1B,OAAOH,OAAO,CAACW,MAAM,CAAC,IAAIC,KAAK,CAAC,uBAAuB,CAAC,CAAC;EAC7D;EAEA,OAAO,IAAIZ,OAAO,CAAC,CAACa,OAAO,EAAEF,MAAM,KAAK;IACpCN,IAAI,CAACS,IAAI,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAK;MACrB,IAAID,GAAG,EAAE;QACLJ,MAAM,CAACI,GAAG,CAAC;MACf,CAAC,MAAM;QACHF,OAAO,CAACG,IAAI,CAAC;MACjB;IACJ,CAAC,CAAC;IAEFb,EAAE,CAACc,KAAK,CAACb,OAAO,EAAEC,IAAI,CAAC;EAC3B,CAAC,CAAC;AACN;;AAEA;AACA,SAASM,MAAMA,CAACI,GAAG,EAAE;EACjB,OAAOf,OAAO,CAACW,MAAM,CAACI,GAAG,CAAC;AAC9B;;AAEA;AACA;AACA,SAASG,GAAGA,CAAChB,OAAO,EAAE;EAClBF,OAAO,GAAGE,OAAO;AACrB;AAEAiB,MAAM,CAACC,OAAO,GAAG;EACblB,OAAO;EACPS,MAAM;EACNO;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}